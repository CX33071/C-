智能指针

一、为啥需要智能指针

在 C++ 里，我们用`new`申请动态内存，必须用`delete p;`释放，但可能会出现这些问题：

- 忘释放：写完代码忘了加`delete`，内存一直被占用，内存泄漏；
- 重复释放：执行了多次`delete`，程序崩溃；
- 释放时机错：代码里有`return`、`throw`等逻辑，导致`delete`没执行到，照样泄漏；
- 野指针：释放内存后没把指针置空，后续代码不小心用了这个 “失效指针”

而智能指针就是替你自动管理内存释放，你只管申请、用，不用还。

二、智能指针的核心原理：RAII 机制

智能指针本质是 C++ 标准库（`<memory>`头文件）提供的模板类，核心是利用RAII 机制：

1. 把`new`出来的裸指针 “交给” 智能指针管理；
2. 智能指针对象存在于栈上，超出作用域时会自动调用析构函数；
3. 析构函数里会自动执行`delete`，把内存还给系统。

简单说：智能指针把 “内存释放” 和 “对象生命周期” 绑定，只要智能指针 “死了”，内存就会被自动释放。

三、3 种智能指针

1. unique_ptr

核心特点

- 一块内存只能被一个`unique_ptr`管理（独占所有权）；
- 不能拷贝、不能赋值，只能通过`std::move`转移所有权；
- 没有引用计数开销，效率和裸指针几乎一样。

适用场景

- 局部动态资源（比如函数里临时申请的内存）；
- 容器里存储独占对象（如`vector<unique_ptr<Person>>`）；
- 所有 “只有一个地方用” 的动态内存场景。

```c++
#include <memory>
#include <iostream>
using namespace std;
int main() {
    // 推荐用make_unique初始化避免裸new
    unique_ptr<int> up = make_unique<int>(10);
    // 用法和普通指针一样
    cout << *up << endl; // 输出10
    *up = 20;
    cout << *up << endl; // 输出20
    // 转移所有权（用move，转移后up就空了）
    unique_ptr<int> up2 = move(up);
    if (!up) {
        cout << "up已经空了" << endl; 
    }
    // 出了main函数，up2析构，自动释放内存
    return 0;
}
```

- 千万别直接拷贝：`unique_ptr<int> up3 = up2;`会直接编译报错，这是保护机制，避免多个人管同一块内存；
- 管理动态数组：`unique_ptr<int[]> up_arr = make_unique<int[]>(5);`，析构时会自动用`delete[]`释放，不用手动处理。

2. shared_ptr

特点

- 一块内存可以被多个`shared_ptr`管理（共享所有权）；
- 内部有 “引用计数”：每多一个`shared_ptr`指向这块内存，计数 + 1；每少一个，计数 - 1；
- 当计数归 0 时，才会自动释放内存。

适用场景

- 多段代码共享同一块资源（比如多线程共享数据）；

- 不确定谁最后用完资源的场景；

- 需要明确知道 “有多少个地方在用这块内存” 的场景。

  ```c++
  #include <memory>
  #include <iostream>
  using namespace std;
  void func(shared_ptr<int> sp) {
      // 函数传参，计数+1
      cout << "函数内计数：" << sp.use_count() << endl; // 输出3
  }
  int main() {
      // 推荐用make_shared初始化
      shared_ptr<int> sp1 = make_shared<int>(10);
      cout << "初始计数：" << sp1.use_count() << endl; // 输出1
      // 拷贝，计数+1
      shared_ptr<int> sp2 = sp1;
      cout << "拷贝后计数：" << sp2.use_count() << endl; // 输出2
      // 传参给函数，计数再+1
      func(sp1);
      // 函数执行完，计数回到2；sp1重置，计数-1
      sp1.reset();
      cout << "sp1重置后计数：" << sp2.use_count() << endl; // 输出1
      // main函数结束，sp2析构，计数归0，内存释放
      return 0;
  }
  ```

  提醒

  - `make_shared`比直接`new`更优：`make_shared`会一次性分配 “对象内存 + 引用计数内存”，而`shared_ptr<int> sp(new int(10))`会分两次分配，效率更低；
  - 管理动态数组要手动指定删除器：`shared_ptr`默认用`delete`释放，管理数组时要写：`shared_ptr<int> sp(new int[5], [](int* p){delete[] p;});`。

  3. weak_ptr

  特点

  - 不拥有内存所有权，也不增加引用计数；
  - 只能从`shared_ptr`或其他`weak_ptr`创建；
  - 不能直接解引用，需通过`lock()`转为`shared_ptr`才能访问对象；
  - 核心作用：解决`shared_ptr`的**循环引用**问题。

  循环引用坑

  如果两个`shared_ptr`互相指向对方，引用计数永远归不了 0，内存永远释放不了：

  ```c++
  // 循环引用导致内存泄漏
  class B;
  class A {
  public:
      shared_ptr<B> b_ptr;
      ~A() { cout << "A析构" << endl; } // 不会执行
  };
  class B {
  public:
      shared_ptr<A> a_ptr;
      ~B() { cout << "B析构" << endl; } // 不会执行
  };
  int main() {
      shared_ptr<A> a = make_shared<A>();
      shared_ptr<B> b = make_shared<B>();
      a->b_ptr = b; // a引用b，b计数+1
      b->a_ptr = a; // b引用a，a计数+1
      // 出作用域后，a、b计数都是1，不会析构，内存泄漏
      return 0;
  }
  ```

  用 weak_ptr 解决循环引用

  ```c++
  // 解决循环引用
  class B2;
  class A2 {
  public:
      shared_ptr<B2> b_ptr;
      ~A2() { cout << "A2析构" << endl; } // 正常执行
  };
  class B2 {
  public:
      weak_ptr<A2> a_ptr; // 改为weak_ptr，不增加计数
      ~B2() { cout << "B2析构" << endl; } // 正常执行
  };
  
  int main() {
      shared_ptr<A2> a2 = make_shared<A2>();
      shared_ptr<B2> b2 = make_shared<B2>();
      a2->b_ptr = b2; // b2计数+1（变为2）
      b2->a_ptr = a2; // a2计数不变（还是1）
      // 出作用域后，a2析构（计数归0），b2计数归1，随后b2析构，内存释放
      return 0;
  }
  
  ```

  #### 适用场景

  - 双向引用场景（如双向链表节点、父子类互相引用）；
  - 只想 “观察” 资源是否存在，不想影响其释放的场景。

  四、避坑错误

  1. 用智能指针管理栈上对象

     错误示例：`int x = 10; unique_ptr<int> up(&x);`

     后果：智能指针析构时会`delete`栈上对象，导致程序崩溃；

     智能指针只管理`new`出来的动态内存。

  2. 裸指针和智能指针混用

     错误示例：`int* p = new int; shared_ptr<int> sp(p); delete p;`

     后果：智能指针析构时会重复释放，程序崩溃；

     一旦把裸指针交给智能指针，就再也不要用裸指针操作这块内存。

  3. unique_ptr 直接拷贝

     错误示例：`unique_ptr<int> up1 = make_unique<int>(10); unique_ptr<int> up2 = up1;`

     后果：编译报错（保护机制）；

     unique_ptr 只能用`std::move`转移所有权。

  4. weak_ptr 直接解引用

     错误示例：`weak_ptr<int> wp = sp; cout << *wp << endl;`

     后果：编译报错；

     先用`wp.lock()`转为 shared_ptr，检查不为空后再用。

  |    类型    |         特点         |        效率        |          适用场景          |
  | :--------: | :------------------: | :----------------: | :------------------------: |
  | unique_ptr |  独占所有权，无计数  |  最高（≈裸指针）   | 单个对象 / 数组的独占管理  |
  | shared_ptr | 共享所有权，引用计数 |  略低（计数开销）  |       多对象共享资源       |
  |  weak_ptr  |    弱引用，不计数    | 和 shared_ptr 一致 | 解决循环引用、观察资源状态 |

  能用 unique_ptr 不用 shared_ptr，能用 shared_ptr+weak_ptr 解决的别用裸指针