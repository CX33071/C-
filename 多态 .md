多态	**C++面向对象三大特性之一**

多态分为两类

- 静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名
- 动态多态: 派生类和虚函数实现运行时多态

1.本质：**同一父类的接口（虚函数），不同子类有不同的实现逻辑，程序运行时会根据对象的**实际类型 **（而非指针 / 引用的声明类型）自动调用对应子类的方法，实现行为的动态适配

2.多态必须满足3个条件

**继承关系**：子类继承父类（通常是 `public` 继承）；

**虚函数**：父类中用 `virtual` 修饰方法，子类**重写**该方法（函数签名完全一致）；

**父类指针 / 引用**：用父类的指针或引用指向子类对象，调用虚函数

3.示例

```c++
#include <iostream>
using namespace std;

// 父类：抽象的“形状”
class Shape {
public:
    // 虚函数：父类定义接口，子类可重写
    virtual double getArea() {
        cout << "形状的面积（默认）" << endl;
        return 0.0;
    }

    // 纯虚函数：强制子类实现（父类无默认逻辑），包含纯虚函数的类是“抽象类”，无法实例化
    virtual void draw() = 0;

    // 虚析构函数：确保子类析构函数被调用（释放子类资源）
    virtual ~Shape() { cout << "Shape 析构" << endl; }
};

// 子类1：圆形（继承 Shape）
class Circle : public Shape {
private:
    double radius; // 半径
public:
    Circle(double r) : radius(r) {}

    // 重写父类虚函数（C++11+ 用 override 显式标记，避免函数签名错误）
    double getArea() override {
        double area = 3.14 * radius * radius;
        cout << "圆形面积：" << area << endl;
        return area;
    }

    // 实现纯虚函数
    void draw() override {
        cout << "绘制圆形" << endl;
    }

    ~Circle() override { cout << "Circle 析构" << endl; }
};

// 子类2：矩形（继承 Shape）
class Rectangle : public Shape {
private:
    double width, height;
public:
    Rectangle(double w, double h) : width(w), height(h) {}

    double getArea() override {
        double area = width * height;
        cout << "矩形面积：" << area << endl;
        return area;
    }

    void draw() override {
        cout << "绘制矩形" << endl;
    }

    ~Rectangle() override { cout << "Rectangle 析构" << endl; }
};

int main() {
    // 父类指针指向子类对象（多态核心）
    Shape* shape1 = new Circle(5.0);
    Shape* shape2 = new Rectangle(4.0, 6.0);

    // 运行时动态绑定：调用子类的实现
    shape1->getArea(); // 输出“圆形面积：78.5”
    shape1->draw();    // 输出“绘制圆形”
    shape2->getArea(); // 输出“矩形面积：24”
    shape2->draw();    // 输出“绘制矩形”

    // 释放内存：虚析构确保先调用子类析构，再调用父类析构
    delete shape1;
    delete shape2;

    return 0;
}

```

4.多态两种类型

(1)静态多态(编译期多态)

编译器编译时确定调用哪个函数，核心实现方式：

- **函数重载**：同一作用域内函数名相同，参数列表（个数 / 类型 / 顺序）不同；

- **运算符重载**：如 `operator+` 重载，本质是函数重载；

- **模板**：类模板 / 函数模板，编译期实例化不同类型的版本。

- 示例：

- ```c++
  // 静态多态：编译期确定调用 add(int, int) 还是 add(double, double)
  int add(int a, int b) { return a + b; }
  double add(double a, double b) { return a + b; }
  
  int main() {
      add(1, 2);    // 调用 int 版本（编译期确定）
      add(1.1, 2.2); // 调用 double 版本（编译期确定）
      return 0;
  }
  
  ```

(2)动态多态

#### 实现条件（缺一不可）

1. **继承关系**：子类 `public` 继承父类；
2. **虚函数**：父类用 `virtual` 修饰函数（定义接口），子类用 `override` 重写（实现专属逻辑）；
3. **父类指针 / 引用**：用父类指针或引用指向子类对象，调用虚函数

- ```c++
  #include <iostream>
  using namespace std;
  
  // 父类：抽象形状（定义接口）
  class Shape {
  public:
      // 纯虚函数：强制子类实现，含纯虚函数的类为抽象类（无法实例化）
      virtual double getArea() = 0;
      // 虚析构函数：确保子类析构被调用（避免资源泄漏）
      virtual ~Shape() {}
  };
  
  // 子类1：圆形（重写接口）
  class Circle : public Shape {
  private:
      double radius;
  public:
      Circle(double r) : radius(r) {}
      // 重写父类虚函数（override 显式标记，编译器检查合法性）
      double getArea() override {
          return 3.14 * radius * radius;
      }
  };
  
  // 子类2：矩形（重写接口）
  class Rectangle : public Shape {
  private:
      double w, h;
  public:
      Rectangle(double width, double height) : w(width), h(height) {}
      double getArea() override {
          return w * h;
      }
  };
  
  int main() {
      // 父类指针指向子类对象（核心）
      Shape* shape1 = new Circle(2.0);
      Shape* shape2 = new Rectangle(3.0, 4.0);
  
      // 运行时动态绑定：调用子类的实现
      cout << "圆形面积：" << shape1->getArea() << endl; // 12.56
      cout << "矩形面积：" << shape2->getArea() << endl; // 12
  
      // 释放内存（虚析构确保子类析构被调用）
      delete shape1;
      delete shape2;
      return 0;
  }
  
  ```

- 底层实现：虚函数表vtable

  - 每个含虚函数的类会生成一张「虚函数表」，存储所有虚函数的地址；
  - 每个对象包含一个「虚指针（vptr）」，指向所属类的虚函数表；
  - 运行时通过 vptr 找到对应子类的虚函数地址，实现动态调用。

5.注意点

(1)子类重写父类虚函数必须满足：

**函数名相同**；

**参数列表相同**（个数、类型、顺序一致）；

**返回值相同**（或协变返回值，如父类返回 `Shape*`，子类返回 `Circle*`）；

C++11+ 用 `override` 关键字显式标记，编译器会检查重写是否合法（避免手滑写错函数名 / 参数）

(2)纯虚函数：`virtual 返回值 函数名() = 0;`，无函数体，强制子类实现；

抽象类：包含纯虚函数的类，**无法实例化**（如 `Shape s;` 编译报错），仅作为父类被继承；

接口类：仅包含纯虚函数的抽象类（如 Java 的 `interface`），用于定义规范

(3)虚析构函数的必要性

若父类析构函数不是虚函数，用父类指针删除子类对象时，只会调用父类析构函数，导致子类资源泄漏。例如：

```c++
// 错误示例：父类析构非虚函数
class Shape {
public:
    ~Shape() { cout << "Shape 析构" << endl; } // 非虚
};
class Circle : public Shape {
public:
    ~Circle() { cout << "Circle 析构" << endl; }
};

int main() {
    Shape* p = new Circle();
    delete p; // 仅调用 Shape 析构，Circle 析构未调用 → 资源泄漏
    return 0;
}

```

6.纯虚函数和抽象类

在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容

因此可以将虚函数改为**纯虚函数**

纯虚函数语法：`virtual 返回值类型 函数名 （参数列表）= 0 ;`

当类中有了纯虚函数，这个类也称为==抽象类==

**抽象类特点**：

- 无法实例化对象
- 子类必须重写抽象类中的纯虚函数，否则也属于抽象类