继承

1.作用：

**代码复用**：避免重复编写父类已有的逻辑（如所有页面都有的头部 / 底部）；

**层次化设计**：将通用逻辑抽离到父类，子类专注实现特有功能；

**为多态铺路**：子类重写父类虚函数，实现「一个接口，多种实现」。

2.语法：

```c++
class 子类名 : 继承方式 父类名 {
    // 子类新增的属性和方法
};

```

3.继承方式：`public`（公有继承）、`protected`（保护继承）、`private`（私有继承）（默认`private`）

| 基类成员权限 | public 继承    | protected 继承   | private 继承   |      |
| ------------ | -------------- | ---------------- | -------------- | ---- |
| public       | 保持 public    | 降级为 protected | 降级为 private |      |
| protected    | 保持 protected | 保持 protected   | 降级为 private |      |
| private      | 不可访问       | 不可访问         | 不可访问       |      |

子类会继承父类的`public`/`protected`成员（`private`成员不可直接访问，但会被继承）,父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到

类内/类外的访问规则

| 成员权限  | 类内（成员函数） | 类外（如 main / 自定义函数） | 子类（子类的成员函数） |
| --------- | ---------------- | ---------------------------- | ---------------------- |
| public    | ✅ 可访问         | ✅ 可访问                     | ✅ 可访问               |
| protected | ✅ 可访问         | ❌ 不可访问                   | ✅ 可访问               |
| private   | ✅ 可访问         | ❌ 不可访问                   | ❌ 不可访问             |

```c++
#include <iostream>
using namespace std;

class Base {
public:
    int pub;
protected:
    int pro;
private:
    int pri;
};

// 公有继承
class PubSon : public Base {
public:
    void show() {
        pub = 10;  // 可访问（public）
        pro = 20;  // 可访问（protected）
        // pri = 30; // 报错：父类private不可访问
    }
};

// 保护继承
class ProSon : protected Base {
public:
    void show() {
        pub = 10;  // 可访问（已变为protected）
        pro = 20;  // 可访问（protected）
    }
};

// 私有继承
class PriSon : private Base {
public:
    void show() {
        pub = 10;  // 可访问（已变为private）
        pro = 20;  // 可访问（已变为private）
    }
};

int main() {
    PubSon ps;
    ps.pub = 100;  // 公有继承：pub仍为public，外部可访问
    // ps.pro = 200; // 报错：protected外部不可访问

    ProSon prs;
    // prs.pub = 100; // 报错：保护继承后pub变为protected，外部不可访问

    PriSon pris;
    // pris.pub = 100; // 报错：私有继承后pub变为private，外部不可访问
    return 0;
}

```

4.示例

```c++
#include <iostream>
using namespace std;

// 父类（基类）：通用逻辑
class Person {
public:
    string name;
    int age;
    void eat() { cout << name << "吃饭" << endl; }
};

// 子类（派生类）：公有继承Person
class Student : public Person {
public:
    int studentId; // 子类特有属性
    void study() { // 子类特有方法
        cout << name << "（学号：" << studentId << "）学习" << endl;
    }
};

int main() {
    Student s;
    s.name = "张三";    // 继承父类的public成员
    s.studentId = 1001; // 子类自有成员
    s.eat();           // 继承父类的方法：输出「张三吃饭」
    s.study();         // 子类自有方法：输出「张三（学号：1001）学习」
    return 0;
}

```

5.注意：

(1) 子类构造函数：必须初始化父类

子类创建对象时，会先调用父类构造函数，再调用子类构造函数；

若父类无默认构造（只有带参构造），子类必须显式初始化父类。

```c++
class Person {
public:
    string name;
    // 父类带参构造（无默认构造）
    Person(string n) : name(n) {}
};

class Student : public Person {
public:
    int id;
    // 子类构造函数：必须通过初始化列表调用父类构造
    Student(string n, int i) : Person(n), id(i) {}
};

int main() {
    Student s("李四", 1002);
    cout << s.name << " " << s.id << endl; // 输出「李四 1002」
    return 0;
}

```

总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反

(2)继承同名成员

问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？

- 访问子类同名成员   直接访问即可

- 访问父类同名成员   需要加作用域

- ```c++
  class Base {
  public:
  	Base()
  	{
  		m_A = 100;
  	}
  
  	void func()
  	{
  		cout << "Base - func()调用" << endl;
  	}
  
  	void func(int a)
  	{
  		cout << "Base - func(int a)调用" << endl;
  	}
  
  public:
  	int m_A;
  };
  
  
  class Son : public Base {
  public:
  	Son()
  	{
  		m_A = 200;
  	}
  
  	//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数
  	//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域
  	void func()
  	{
  		cout << "Son - func()调用" << endl;
  	}
  public:
  	int m_A;
  };
  
  void test01()
  {
  	Son s;
  
  	cout << "Son下的m_A = " << s.m_A << endl;
  	cout << "Base下的m_A = " << s.Base::m_A << endl;
  
  	s.func();
  	s.Base::func();
  	s.Base::func(10);
  
  }
  int main() {
  
  	test01();
  
  	system("pause");
  	return EXIT_SUCCESS;
  }
  ```

- 子类对象可以直接访问到子类中同名成员

- 子类对象加作用域可以访问到父类同名成员

- 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数

(3)同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）

```c++
void test01()
{
	//通过对象访问
	cout << "通过对象访问： " << endl;
	Son s;
	cout << "Son  下 m_A = " << s.m_A << endl;
	cout << "Base 下 m_A = " << s.Base::m_A << endl;

	//通过类名访问
	cout << "通过类名访问： " << endl;
	cout << "Son  下 m_A = " << Son::m_A << endl;
	cout << "Base 下 m_A = " << Son::Base::m_A << endl;
}
```

6.多继承语法

语法：` class 子类 ：继承方式 父类1 ， 继承方式 父类2...`

多继承可能会引发父类中有同名成员出现，需要加作用域区分

```c++
class Base1 {
public:
	Base1()
	{
		m_A = 100;
	}
public:
	int m_A;
};

class Base2 {
public:
	Base2()
	{
		m_A = 200;  //开始是m_B 不会出问题，但是改为mA就会出现不明确
	}
public:
	int m_A;
};

//语法：class 子类：继承方式 父类1 ，继承方式 父类2 
class Son : public Base2, public Base1 
{
public:
	Son()
	{
		m_C = 300;
		m_D = 400;
	}
public:
	int m_C;
	int m_D;
};


//多继承容易产生成员同名的情况
//通过使用类名作用域可以区分调用哪一个基类的成员
void test01()
{
	Son s;
	cout << "sizeof Son = " << sizeof(s) << endl;
	cout << s.Base1::m_A << endl;
	cout << s.Base2::m_A << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

