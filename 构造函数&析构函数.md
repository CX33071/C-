构造函数&析构函数

C++利用这两个函数来完成对象初始化和清理工作，对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供，编译器提供的构造函数和析构函数是空实现

- 构造函数：创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。
- 析构函数：对象**销毁前**系统自动调用，执行一些清理工作。

**构造函数语法：**`类名(){}`

1. 构造函数，没有返回值也不写void
2. 函数名称与类名相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次

**析构函数语法：** `~类名(){}`

1. 析构函数，没有返回值也不写void
2. 函数名称与类名相同,在名称前加上符号  ~
3. 析构函数不可以有参数，因此不可以发生重载
4. 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次

基础框架

```c++
class Person
{
public:
	//构造函数
	Person()
	{
		cout << "Person的构造函数调用" << endl;
	}
	//析构函数
	~Person()
	{
		cout << "Person的析构函数调用" << endl;
	}

};

void test01()
{
	Person p;
}

int main() {
	
	test01();

	system("pause");

	return 0;
}
```

构造函数分为普通构造和拷贝构造，普通构造又分为有参苟造和无参构造

```c++
class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout << "无参构造函数!" << endl;
	}
	//有参构造函数
	Person(int a) {
		age = a;
		cout << "有参构造函数!" << endl;
	}
	//拷贝构造函数
	Person(const Person& p) {
		age = p.age;
		cout << "拷贝构造函数!" << endl;
	}
	//析构函数
	~Person() {
		cout << "析构函数!" << endl;
	}
public:
	int age;
};
```

构造函数的3种调用方式：括号法、显示法、隐式转换法

```c++
//调用无参构造函数
void test01() {
	Person p; //调用无参构造函数
}

//调用有参的构造函数
void test02() {

	//2.1  括号法，常用
	Person p1(10);
	//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明
	//Person p2();

	//2.2 显式法
	Person p2 = Person(10); 
	Person p3 = Person(p2);
	//Person(10)单独写就是匿名对象  当前行结束之后，马上析构

	//2.3 隐式转换法
	Person p4 = 10; // Person p4 = Person(10); 
	Person p5 = p4; // Person p5 = Person(p4); 
}

```

拷贝构造函数调用时机：使用一个已经创建完毕的对象来初始化一个新对象、值传递的方式给函数参数传值、以值方式返回局部对象

```c++
class Person {
public:
	Person() {
		cout << "无参构造函数!" << endl;
		mAge = 0;
	}
	Person(int age) {
		cout << "有参构造函数!" << endl;
		mAge = age;
	}
	Person(const Person& p) {
		cout << "拷贝构造函数!" << endl;
		mAge = p.mAge;
	}
	//析构函数在释放内存之前调用
	~Person() {
		cout << "析构函数!" << endl;
	}
public:
	int mAge;
};

//1. 使用一个已经创建完毕的对象来初始化一个新对象
void test01() {

	Person man(100); //p对象已经创建完毕
	Person newman(man); //显示调用拷贝构造函数
	Person newman2 = man; //隐式调用拷贝构造函数

	//Person newman3;
	//newman3 = man; //不是调用拷贝构造函数，赋值操作
}

//2. 值传递的方式给函数参数传值
//相当于Person p1 = p;
void doWork(Person p1) {}
void test02() {
	Person p; //无参构造函数
	doWork(p);//隐式调用拷贝构造函数
}

//3. 以值方式返回局部对象
Person doWork2()
{
	Person p1;
	cout << (int *)&p1 << endl;
	return p1;
}

void test03()
{
	Person p = doWork2();//若没有编译器优化，隐式调用两次拷贝构造函数，第一次调用将局部变量拷贝给一个临时变量，第二次调用将临时变量拷贝给最终变量，但是如果编译器优化，0次调用，直接在最终对象上创建，原地构造
	cout << (int *)&p << endl;
}


int main() {

	//test01();
	//test02();
	test03();

	system("pause");

	return 0;
}
```

若自己什么构造函数都没提供，编译器自动提供无参构造函数和浅拷贝构造函数，只有自己什么函数都不提供的时候编译器才给提供无参构造函数，若提供了一个不论什么函数编译器就不会提供无参构造函数了，但是如果后续调用无参构造函数你却没有提供编译器有报错，如果自己只提供有参构造函数，编译器会自动提供浅拷贝构造函数，如果自己只提供拷贝构造函数编译器不会再提供任何函数了

构析函数：

无需手动调用，对象销毁时由编译器自动触发，若类中未显式定义编译器会生成默认析构函数，但是默认西沟函数仅释放对象本身的的内存，不处理动态分配的资源，这是内存泄漏的常见原因

什么时候需要定义显式西沟函数？

当类中中包含动态分配的内存时（new分配的内存、`malloc`）、需要手动释放的资源（文件指针FILE*、网络套接字）

```c++
#include <iostream>
using namespace std;

class MyArray {
private:
    int* arr;
public:
    MyArray(int size) {
        arr = new int[size];
        cout << "构造函数：分配堆内存" << endl;
    }

    // 显式定义析构函数，释放动态内存
    ~MyArray() {
        delete[] arr;  // 释放new[]分配的数组（注意匹配new[]和delete[]）
        cout << "析构函数：释放了堆内存" << endl;
    }
};

int main() {
    {
        MyArray arr(100);  // 构造函数执行
    }  // 离开作用域，析构函数自动执行，内存被释放
    return 0;
}

```

调用时机：

1. 局部对象离开其作用域（如代码块 `{}` 结束）；
2. 动态分配的对象被 `delete` 关键字释放；
3. 全局对象或静态对象（`static`）在程序结束时；
4. 容器（如 `vector`）销毁时，会自动调用其存储对象的析构函数。