模板

1.本质：编译期的代码生成工具—— 它允许你编写「与类型无关」的通用代码，编译器会根据实际传入的类型，自动生成对应类型的具体代码

2.模板的分类

函数模板、类模板

- 函数模板

  语法：

  ```c++
  // 模板参数列表：typename/class 声明类型参数（typename和class等价）
  template <typename T1, typename T2> // 可声明多个类型参数
  返回值类型 函数名(参数列表) {
      // 通用逻辑（与类型T1/T2相关）
  }
  
  ```

  示例：

  ```c++
  #include <iostream>
  #include <string>
  using namespace std;
  
  // 函数模板：通用加法
  template <typename T>
  T add(T a, T b) {
      return a + b;
  }
  
  int main() {
      // 1. 自动推导类型
      cout << add(1, 2) << endl;          // T=int → 输出3
      cout << add(3.14, 6.28) << endl;    // T=double → 输出9.42
  
      // 2. 显式指定类型（解决推导歧义）
      cout << add<double>(1, 3.14) << endl; // 强制T=double → 输出4.14
      cout << add<string>("Hello", "World") << endl; // T=string → 输出HelloWorld
  
      return 0;
  }
  
  ```

  - 类模板

    语法：

    ```c++
    template <typename T, typename U = int> // 可指定默认类型参数
    class 类名 {
    public:
        // 成员变量/函数，使用T/U
        T data;
        U func(T a) { return (U)a; }
    };
    
    ```

    示例：

    ```c++
    #include <iostream>
    using namespace std;
    
    // 类模板：简单的栈容器
    template <typename T, int Size = 10> // 类型参数+非类型参数（整数）
    class Stack {
    private:
        T arr[Size];
        int top; // 栈顶指针
    public:
        Stack() : top(-1) {}
    
        // 入栈
        void push(const T& val) {
            if (top < Size-1) arr[++top] = val;
        }
    
        // 出栈
        T pop() {
            return arr[top--];
        }
    };
    
    int main() {
        // 实例化：T=int，Size=5（覆盖默认值10）
        Stack<int, 5> intStack;
        intStack.push(10);
        intStack.push(20);
        cout << intStack.pop() << endl; // 输出20
    
        // 实例化：T=string，Size=10（使用默认值）
        Stack<string> strStack;
        strStack.push("Hello");
        strStack.push("Template");
        cout << strStack.pop() << endl; // 输出Template
    
        return 0;
    }
    
    ```

    类模板的成员函数只支持类外定义

