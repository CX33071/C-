深拷贝&浅拷贝

浅拷贝：只拷贝指针变量本身，也就是地址，导致两个指针指向同一块堆内存,修改一个对象也会修改另一个；

深拷贝：拷贝指针变量，还会新开辟一块堆内存，将原指针指向的数据复制到新内存中

```c++
#include <iostream>
#include <cstring> // 用于strcpy字符串拷贝
using namespace std;

// 带堆内存成员的类（演示浅拷贝/深拷贝）
class Person {
public:
    // 构造函数：在堆上开辟内存存储姓名
    Person(const char* name, int age) {
        cout << "调用构造函数，开辟堆内存" << endl;
        m_age = age;
        // 堆上开辟内存（长度=字符串长度+1，预留'\0'结束符）
        m_name = new char[strlen(name) + 1];
        strcpy(m_name, name); // 将传入的姓名复制到堆内存
    }

    // 1. 浅拷贝（编译器默认生成的拷贝构造函数就是浅拷贝）
    // 注意：这里显式写出浅拷贝构造函数，模拟编译器默认行为
    Person(const Person& other) {
        cout << "调用【浅拷贝】构造函数" << endl;
        m_age = other.m_age; // 拷贝栈上的普通变量（没问题）
        m_name = other.m_name; // 只拷贝指针地址，不拷贝堆内存数据！
    }

    // 2. 深拷贝（自定义拷贝构造函数，解决浅拷贝问题）
    // 注释上面的浅拷贝构造函数，取消下面的注释，即可测试深拷贝
    /*
    Person(const Person& other) {
        cout << "调用【深拷贝】构造函数" << endl;
        m_age = other.m_age; // 拷贝普通变量
        // 新开辟一块堆内存（和原对象的堆内存大小一致）
        m_name = new char[strlen(other.m_name) + 1];
        strcpy(m_name, other.m_name); // 拷贝堆内存中的数据到新内存
    }
    */

    // 析构函数：释放堆内存（避免内存泄漏）
    ~Person() {
        cout << "调用析构函数，释放堆内存：" << (void*)m_name << endl;
        if (m_name != nullptr) {
            delete[] m_name; // 释放堆上的字符串内存
            m_name = nullptr; // 避免野指针
        }
    }

    // 打印对象信息（查看姓名和指针地址）
    void showInfo() {
        cout << "姓名：" << m_name 
             << "，年龄：" << m_age 
             << "，姓名内存地址：" << (void*)m_name << endl;
    }

private:
    char* m_name; // 指针成员，指向堆上的字符串
    int m_age;    // 普通成员变量（栈上存储）
};

int main() {
    // 1. 创建原对象p1（构造函数开辟堆内存）
    Person p1("张三", 20);
    p1.showInfo();

    // 2. 用p1拷贝构造p2（触发浅拷贝/深拷贝）
    Person p2 = p1;
    p2.showInfo();

    return 0;
}

```



